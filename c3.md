# 第三章 房间和区域概念

## 介绍

在本文中，我们将介绍一些在实际开发游戏逻辑之前的一些框架结构代码。我们将探讨“房间（Room）”的概念，该概念等同于其他游戏引擎中所谓的“场景（Scene）”。然后，我们将探讨“区域（Area）”的概念，这是一个用来管理对象的类，它可以在`Room`类中实例化。像之前两篇教程一样，本教程仍然没有特定于该游戏的代码（即这些代码是通用的），并将专注于更高层次的、框架结构方向的解决方案。

## 房间（Room）

我是从 [GameMaker 文档]()中想到了房间这个概念。在弄清楚如何解决游戏框架设计问题时，我想做的一件事就是去看看他人是如何解决的。在这种情况下，即使我从未使用过 GameMaker，他们对房间的看法和围绕它实现的功能给了我一些非常好的启发。

就像描述的那样，房间是游戏中一切事情发生的地方（即一切行为都发生在房间里）。它们是创建、更新和绘制所有游戏对象的载体，你可以从一个房间切换到另一个房间。这些房间也只是普通的对象，我将其放置在`rooms`目录下。一个名为`Stage`的房间代码大致如下：

```lua
Stage = Object:extend()

function Stage:new()

end

function Stage:update(dt)

end

function Stage:draw()

end
```

## 简单房间框架设计

在最简单的形式中，这个系统只需要一个额外的变量和一个额外的函数即可工作：

```lua
function love.load()
    current_room = nil
end

function love.update(dt)
    if current_room then current_room:update(dt) end
end

function love.draw()
    if current_room then current_room:draw() end
end

function gotoRoom(room_type, ...)
    current_room = _G[room_type](...)
end
```

首先，在`love.load`中定义了一个全局变量`current_room`。这个设想是，在任何时候当前只有一个房间可以处于活跃状态，于是这个变量就保存了当前处于活跃状态的房间对象的引用。然后在`love.update`和`love.draw`函数中，判断如果当前有任意房间处于活跃状态，则将其更新和绘制。这同时也意味着，所有房间类都必须定义一个更新和一个绘制函数。

`gotoRoom`函数可以用于切换不同的房间。它接受一个`room_type`参数，它只是一个字符串，包含我们想要更改到的房间类的名称。例如，如果定义了一个名为`Stage`的房间类，则意味着这里需要传`Stage`字符串作为参数。这里这么做可以生效也是基于之前教程中设置的自动加载类功能，它会将所有类加载并绑定到对应的全局变量。

在 Lua 中，全局变量保存在名为`_G`的全局环境表中，这意味着你可以像访问其他普通表中的元素一样访问它们。如果全局变量`Stage`包含了`Stage`类的定义，则可以在程序的任意位置通过直接写`Stage`来访问它，也可以写成`_G['Stage']`或`_G.Stage`。因为我们希望能够加载任意房间，因此有必要先接受`room_type`这个字符串，再通过它及全局表来访问到类定义。

最终，如果`room_type`是字符串`Stage`，则`gotoRoom`函数内的那一行代码将变成`current_room = Stage(...)`，这意味着将实例化一个新的`Stage`房间。同时意味着，每当切换到一个新的房间时，都会从头开始创建一个新的房间实例，并删除前一个房间实例。它在 Lua 中的工作方式是，每当不再有任何可达的变量引用到表时，垃圾回收器最终会将其回收。这里当`current_room`变量不再引用先前的房间实例时，该实例最终将被垃圾回收器回收释放。

不过这样的设计也有明显的局限性，例如，很多时候虽然你切换了一个房间，但你并不想将之间的房间删除掉，并且通常情况下你也不希望每次进入一个新房间，它都是从头开始创建。在上述设计中，没办法避免这些情况。

对于当前这个游戏来说，上述设计就是我将使用的。这个游戏一共只会有 3 ~ 4 个房间，而且这些房间之间都没有连续性，也就是说，每当我们切换一个新房间，完全可以删除旧的房间，从头创建新的房间，这样可以达到我们想要的效果。

-----

让我们通过一个小例子来说明如何将上述系统映射到一个真实存在的游戏上。一起来看一下 Nuclear Throne：

![1](https://camo.githubusercontent.com/d9b57cc7347f4e4b1e7007de5dfbf04ffb473133/68747470733a2f2f692e696d6775722e636f6d2f746477303030332e706e67)

观看[此视频](https://www.bilibili.com/video/BV1JK411n7GC?from=search&seid=17532654389431628927)前 5 分钟，以了解游戏整体面貌。

> 译注：原视频地址为 https://www.youtube.com/watch?v=SsD6oRQWM6k

游戏循环非常简单，对于上述简单房间框架设计来说，它非常合适，因为没有一个房间与前一个房间有连续性（例如，你无法返回上一张地图）。你看到的第一个屏幕画面是主菜单：

![2](https://camo.githubusercontent.com/181e4586dcaae238206a3083c01f08367fc0b1fd/68747470733a2f2f692e696d6775722e636f6d2f5065364b48366e2e706e67)

我将其创建为`MainMenu`房间类，其中包含了上图中菜单所需的全部逻辑。因此它包含背景、五个选项、选择新选项时的效果，屏幕边缘的闪电等，每当玩家选择一个选项时，我都会调用`gotoRoom(option_type)`切换至对应选项房间。在这个例子中，我们还将拥有`Play`、`CO-OP`、`Settings`和`Stats`这几个房间。

或者，你可以在`MainMenu`房间中处理所有选项，这样你只需要一个房间。通常情况下，将所有内容放在一个房间处理，而不是通过外部系统来跳转到不同的房间是一个跟好的主意。这取决于实际情况，不过对于这个例子来说，没有足够的细节来判断哪个设计更好。

无论如何，视频中发生的下一件事是玩家选择了`Play`选项，如下所示：

![3](https://camo.githubusercontent.com/9f77c60ff8096027006d26474965e55450901af9/68747470733a2f2f692e696d6775722e636f6d2f484a4d305644652e706e67)

出现新选项，你可以在普通、日常和周常模式中进行选择。据我所知，这些不同选项仅仅只是更改关卡生成器种子，在这种情况下，我们无需再为每个选项新增一个房间（只需要在`gotoRoom`调用中传递不同的种子作为参数即可）。视频中玩家选择普通模式，然后出现如下界面：

![4](https://camo.githubusercontent.com/aa16102b122a5b312e4b428b8e8b3cf837fddc5d/68747470733a2f2f692e696d6775722e636f6d2f64674b457651442e706e67)

我将其称为`CharacterSelect`房间，和其他房间一样，它具有显示成屏幕上效果那样所需的一切逻辑。背景、背景中的角色，选择不同角色时产生的效果以及选择角色本身应实现的逻辑。一旦选择了角色，就会出现加载界面：

![5](https://camo.githubusercontent.com/54506bdb3c384c270e7320a3d6b3d2d692495b9e/68747470733a2f2f692e696d6775722e636f6d2f44744f5637444a2e706e67)

接着是游戏界面：

![6](https://camo.githubusercontent.com/51779778e64980e6aa3c575a219d5aed7245f85d/68747470733a2f2f692e696d6775722e636f6d2f706c717350366b2e706e67)

当玩家完成当前关卡，进入下一关之前弹出的中转界面：

![7](https://camo.githubusercontent.com/f8c6ab2c8b2f7bc62251a57e4d50bb667abaca69/68747470733a2f2f692e696d6775722e636f6d2f3047486a616f542e706e67)

一旦玩家从上面的界面中选择了被动能力后，就会显示另一个加载界面。然后游戏进入下一个关卡。最后当玩家死亡时显示如下界面：

![8](https://camo.githubusercontent.com/89f9ce2c0e02c0b5b5dd3398f502308f876bb015/68747470733a2f2f692e696d6775722e636f6d2f58424e466953632e706e67)

上述所有这些都是不同的界面，如果要遵循直到现在为止我遵循的逻辑，我会将它们全部设置为不同的房间：`LoadingScreen`、`Game`、`MutationSelect`和`DeathScreen`。不过，如果你仔细想想，其中有些房间就显得多余了。

例如，没有理由将`LoadingScreen`从`Game`中单独分离出来。正在加载的逻辑可能与关卡生成器有关，而关卡生成器又是在进入`Game`房间后开始执行，因此将加载单独抽离出去是没有意义的，因为抽离出来后，加载逻辑就必须在`LoadingScreen`中进行，而不是在`Room`中进行，还必须得将在`LoadingScreen`逻辑里创建的数据传递给`Game`。我认为这是不必要的过度复杂。

另一个是死亡界面，它只是在游戏界面上覆盖了一层新的界面（游戏仍在运行），这意味着它也可能与游戏放在同一房间中。最后，我认为唯一真正可能是单独房间的是`MutationSelect`。

就房间而言，Nuclear Throne 的游戏循环，就像视频中所展现的那样：`MainMenu` -> `Play` -> `CharacterSelect` -> `Game` -> `MutationSelect` -> `Game` -> ...。如果发生死亡，你可以返回到新的`MainMenu`或重试`Game`。所有这些转换都可以通过简单的`gotoRoom`函数来实现。
