# 第三章 房间和区域概念

## 介绍

在本文中，我们将介绍一些在实际开发游戏逻辑之前的一些框架结构代码。我们将探讨“房间（Room）”的概念，该概念等同于其他游戏引擎中所谓的“场景（Scene）”。然后，我们将探讨“区域（Area）”的概念，这是一个用来管理对象的类，它可以在`Room`类中实例化。像之前两篇教程一样，本教程仍然没有特定于该游戏的代码（即这些代码是通用的），并将专注于更高层次的、框架结构方向的解决方案。

## 房间（Room）

我是从 [GameMaker 文档]()中想到了房间这个概念。在弄清楚如何解决游戏框架设计问题时，我想做的一件事就是去看看他人是如何解决的。在这种情况下，即使我从未使用过 GameMaker，他们对房间的看法和围绕它实现的功能给了我一些非常好的启发。

就像描述的那样，房间是游戏中一切事情发生的地方（即一切行为都发生在房间里）。它们是创建、更新和绘制所有游戏对象的载体，你可以从一个房间切换到另一个房间。这些房间也只是普通的对象，我将其放置在`rooms`目录下。一个名为`Stage`的房间代码大致如下：

```lua
Stage = Object:extend()

function Stage:new()

end

function Stage:update(dt)

end

function Stage:draw()

end
```

## 简单房间

在最简单的形式中，这个系统只需要一个额外的变量和一个额外的函数即可工作：

```lua
function love.load()
    current_room = nil
end

function love.update(dt)
    if current_room then current_room:update(dt) end
end

function love.draw()
    if current_room then current_room:draw() end
end

function gotoRoom(room_type, ...)
    current_room = _G[room_type](...)
end
```

首先，在`love.load`中定义了一个全局变量`current_room`。这个设想是，在任何时候当前只有一个房间可以处于活跃状态，于是这个变量就保存了当前处于活跃状态的房间对象的引用。然后在`love.update`和`love.draw`函数中，判断如果当前有任意房间处于活跃状态，则将其更新和绘制。这同时也意味着，所有房间类都必须定义一个更新和一个绘制函数。

`gotoRoom`函数可以用于切换不同的房间。它接受一个`room_type`参数，它只是一个字符串，包含我们想要更改到的房间类的名称。例如，如果定义了一个名为`Stage`的房间类，则意味着这里需要传`Stage`字符串作为参数。这里这么做可以生效也是基于之前教程中设置的自动加载类功能，它会将所有类加载并绑定到对应的全局变量。

在 Lua 中，全局变量保存在名为`_G`的全局环境表中，这意味着你可以像访问其他普通表中的元素一样访问它们。如果全局变量`Stage`包含了`Stage`类的定义，则可以在程序的任意位置通过直接写`Stage`来访问它，也可以写成`_G['Stage']`或`_G.Stage`。因为我们希望能够加载任意房间，因此有必要先接受`room_type`这个字符串，再通过它及全局表来访问到类定义。

最终，如果`room_type`是字符串`Stage`，则`gotoRoom`函数内的那一行代码将变成`current_room = Stage(...)`，这意味着将实例化一个新的`Stage`房间。同时意味着，每当切换到一个新的房间时，都会从头开始创建一个新的房间实例，并删除前一个房间实例。它在 Lua 中的工作方式是，每当不再有任何可达的变量引用到表时，垃圾回收器最终会将其回收。这里当`current_room`变量不再引用先前的房间实例时，该实例最终将被垃圾回收器回收释放。

不过这样的设置也有明显的局限性，例如，很多时候虽然你切换了一个房间，但你并不想将之间的房间删除掉，并且通常情况下你也不希望每次进入一个新房间，它都是从头开始创建。在上述设计中，没办法避免这些情况。

对于当前这个游戏来说，上述设计就是我将使用的。这个游戏一共只会有 3 ~ 4 个房间，而且这些房间之间都没有连续性，也就是说，每当我们切换一个新房间，完全可以删除旧的房间，从头创建新的房间，这样可以达到我们想要的效果。
