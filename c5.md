# 第五章 游戏基础

## 简介

在这一章中，我们将开始介绍游戏本身的逻辑。首先，我们会从游戏玩法的角度来概述整个游戏的结构，接着我们将重点介绍贯穿整个游戏各部分的通用基础内容，例如像素化外观、摄像头，以及物理模拟等。之后，我们将介绍玩家的移动操作，最后，我们将研究垃圾回收以及如何注意到可能的内存泄漏。

## 游戏框架

游戏本身只会被分为 3 个不同的房间：`Stage`、`Console`和`SkillTree`。

`Stage`房间是游戏玩法真正体现的地方（即玩家游玩的场景），它将具有诸如玩家、敌人、弹药、资源、道具等。游戏玩法与 [Bit Blaster XL](http://store.steampowered.com/app/433950/) 非常相似，实际上也相当简单。我之所以选择这种简单的玩法，是因为简单的玩法可以让我更加专注于开发游戏的其他方面（巨大的技能树）。

![1](https://user-images.githubusercontent.com/409773/41510107-e6fdafc6-7234-11e8-91d2-7bc4ab622f57.gif)

`Console`房间是一个类似“菜单”的地方，在这里可以更改视频、音频设置，查看成就，选择要玩的飞船，访问技能树等等。这里模拟了一个终端，而不是采用传统的菜单选项，对于具有“计算机观感”的游戏（也称为“懒惰的程序员艺术” xD）来说，这样做显得更有意义。并且这个创意是你（玩家）只是通过某地的终端设备进行游戏。

![2](https://user-images.githubusercontent.com/409773/41510105-e6aeee2c-7234-11e8-8dd7-5a0b2bb8d159.gif)

`SkillTree`房间是可以获取所有被动技能的地方。在`Stage`房间中你可以获取随机生成的 SP（skill points），或者击杀敌人也可以获得。之后一旦你死亡，你可以使用这些技能点数购买被动技能。这里是想尝试像 [Path of Exile](https://www.pathofexile.com/passive-skill-tree) 中的技能树，并且我认为在这方面确实取得了一定的成功。我构造的技能树有 600 - 800 个节点，我认为这已经足够了。

![3](https://user-images.githubusercontent.com/409773/41510106-e6d9ebb8-7234-11e8-98ae-5d04e210429f.gif)

我将详细地介绍每个房间的创建，包括技能书中的全部技能。不过，我也强烈建议你尽可能地不要照搬我写的这些内容。我在游戏玩法上做出的许多设计几乎都是我个人偏好，你可能会喜欢一些不同的内容。

例如，抛开庞大的技能树，你可能更加喜欢职业系统，该系统允许更加丰富的组合，像 [Tree of Savior](http://www.tosbase.com/game/classes/) 那样。因此，你可以跟随教程学习各种被动技能的实现方法，然后利用它们构建属于你自己的职业系统，而不是像我一样构建技能树系统。

上面所说也仅仅只是举个例子，你可以在方方面面按照自己的想法来实现。我编写这些教程并包含丰富的练习的原因之一就是鼓励大家自己参与学习，而不仅仅跟着照做，我认为这样才能更好地学习。因此。只要你有机会做一些不同的内容，请务必尝试一下。

## 游戏显示尺寸

让我们从`Stage`开始，我们想要做的第一件事（对于所有房间都是如此）是要使画面具有低分辨率像素风外观。例如，请看下面这个圆：

![](https://camo.githubusercontent.com/be4b0d271fef87475119a841439f530b0329e510/687474703a2f2f692e696d6775722e636f6d2f5957645a3879332e706e67)

然后再看看这个圆：

![](https://camo.githubusercontent.com/a88d49f7af552a1131ccf4310a4c2d0c26eb1063/687474703a2f2f692e696d6775722e636f6d2f455975525761622e706e67)

我想要的效果是第二个。这样的选择纯粹是出于审美和我个人喜好。有很多游戏并没有采用像素风，但仍然通过简单的形状和颜色达到非常好看的效果，比如[这个](http://www.glitchskier.com/)。因此，一个游戏的观感取决于你选择哪种样式以及你可以打磨的程度。但是对于我们这款游戏来说，我将采用像素风。

实现该目标的第一步是定义一个非常小的默认分辨率，最好可以将其直接缩放至目标分辨率`1920x1080`。对于该游戏，我将采用`480x270`，因为这是目标分辨率`1920x1080`除以 4 的值。默认情况下，要将游戏的大小设置为该尺寸，我们需要`conf.lua`文件，正如我在前面文章中介绍的那样，它是一个配置文件，其中定义了一个 LÖVE 项目相关的所有配置，包括窗口初始分辨率。

最重要的是，在此文件中，我还定义了两个全局变量`gw`和`gh`，分别对应基本分辨率的宽和高，以及全局变量`sx`和`sy`，分别对应应用于基础分辨率上的缩放比例。`conf.lua`文件应该和`main.lua`放在同一个目录下，它看起来如下所示：

```lua
gw = 480 
gh = 270 
sx = 1
sy = 1

function love.conf(t)
    t.identity = nil                   -- 游戏标识，保存目录的名字（字符串）
    t.version = "0.10.2"               -- 游戏使用的 LÖVE 的版本号（字符串）
    t.console = false                  -- 是否附加一个 Console（布尔值，仅 Windows 平台）
 
    t.window.title = "BYTEPATH"        -- 窗口名称（字符串）
    t.window.icon = nil                -- 窗口图标路径（字符串）
    t.window.width = gw                -- 窗口宽度（数字）
    t.window.height = gh               -- 窗口高度（数字）
    t.window.borderless = false        -- 窗口是否无边框（布尔值）
    t.window.resizable = true          -- 窗口是否可以改变大小（布尔值）
    t.window.minwidth = 1              -- 窗口宽度最小值，仅当可以改变窗口大小时生效（数字）
    t.window.minheight = 1             -- 窗口高度最小值，仅当可以改变窗口大小时生效（数字）
    t.window.fullscreen = false        -- 是否可以全屏（布尔值）
    t.window.fullscreentype = "exclusive" -- 标准全屏还是窗口全屏（字符串）
    t.window.vsync = true              -- 是否开启垂直同步（布尔值）
    t.window.fsaa = 0                  -- 多重采样抗锯齿采样数（数字）
    t.window.display = 1               -- 目标显示器索引（数字）
    t.window.highdpi = false           -- 在视网膜屏上是否开启高 dpi 模式（布尔值）
    t.window.srgb = false              -- 是否启用伽马校正（布尔值）
    t.window.x = nil                   -- 窗口显示位置 x（数字）
    t.window.y = nil                   -- 窗口显示位置 y（数字）
 
    t.modules.audio = true             -- 是否开启音频模块（布尔值）
    t.modules.event = true             -- 是否开启事件模块（布尔值）
    t.modules.graphics = true          -- 是否开启图形模块（布尔值）
    t.modules.image = true             -- 是否开启图片模块（布尔值）
    t.modules.joystick = true          -- 是否开启摇杆模块（布尔值）
    t.modules.keyboard = true          -- 是否开启键盘模块（布尔值）
    t.modules.math = true              -- 是否开启数学模块（布尔值）
    t.modules.mouse = true             -- 是否开启鼠标模块（布尔值）
    t.modules.physics = true           -- 是否开启物理模块（布尔值）
    t.modules.sound = true             -- 是否开启音效模块（布尔值）
    t.modules.system = true            -- 是否开启系统模块（布尔值）
    t.modules.timer = true             -- 是否开启计时器模块（布尔值）
    t.modules.window = true            -- 是否开启窗口模块（布尔值）
    t.modules.thread = true            -- 是否开启线程模块（布尔值）
end
```

如果现在运行游戏，你会看到一个比之前小很多的窗口。

现在，当我们放大窗口至目标分辨率时，为了得到像素化观感还需要一些额外的工作。如果你现在在窗口中心（坐标 `gw / w, gh / w`）画一个圆，你会看到下面的效果：

![](https://camo.githubusercontent.com/e5ef1f366f48d252567698b185b054eed911b7eb/687474703a2f2f692e696d6775722e636f6d2f7a7a594761786e2e706e67)

通过调用[`love.window.setMode`](https://love2d.org/wiki/love.window.setMode)来直接放大窗口，比如设置宽`3 * gw`和高`3 * gh`，你将得到下面的效果：

![](https://camo.githubusercontent.com/99ade8317a56f313683210722a8fb0a5268703ac/687474703a2f2f692e696d6775722e636f6d2f565970596b57472e706e67)

如你所见，圆并没有随着窗口的放大而放大，仍然是一个小圆。而且它也没有保持在窗口中心，因为当窗口缩放 3 倍后，`gw / 2`和`gh / 2`并不再是窗口的正中心位置。我们想要的是，在基础分辨率`480 x 270`下绘制一个小圆，当窗口缩放至目标分辨率来适配普通显示器时，圆也会按比例放大（以像素化的方式），并且它的位置也按比例保持不变。最简单实现该效果的方式是使用[画布（Canvas）](https://love2d.org/wiki/Canvas)，在其它游戏引擎中，它也被称为 framebuffer 或 render target。首先，我们将在`Stage`类的构造函数里创建一个具有基础分辨率的画布：

```lua
function Stage:new()
    self.area = Area(self)
    self.main_canvas = love.graphics.newCanvas(gw, gh)
end
```

这将创建一个尺寸为`480 x 270`的画布，然后我们可以对其进行绘制：

```lua
function Stage:draw()
    love.graphics.setCanvas(self.main_canvas)
    love.graphics.clear()
        love.graphics.circle('line', gw/2, gh/2, 50)
        self.area:draw()
    love.graphics.setCanvas()
end
```

这里展示的绘制画布的用法只是简单地参考了[画布文档](https://love2d.org/wiki/Canvas)的示例。根据页面上的内容，当我们想在画布上绘制内容时，我们需要调用[`love.graphics.setCanvas`](https://love2d.org/wiki/love.graphics.setCanvas)，它会将所有绘制操作重定向到当前设置好的画布上。接着，我们调用[`love.graphics.clear`](https://love2d.org/wiki/love.graphics.clear)，它将清除此画布上已经绘制过的内容，因为上一帧我们也是用它绘制的，每一帧我们都需要从头开始重新绘制我们需要的内容。然后，我们就可以绘制我们需要的内容。最后，再次调用`setCanvas`，然而这一次不用传递任何参数，因此，之后再绘制的内容也不会被重定向当我们的画布上了。

如果我们在此停止，则屏幕上不会显示任何内容。是因为，我们绘制的所有内容都在画布上，但我们并没有绘制画布本身（即没有将画布的内容显示到屏幕上）。因此，现在我们需要将画布本身绘制到屏幕上，代码如下所示：

```lua
function Stage:draw()
    love.graphics.setCanvas(self.main_canvas)
    love.graphics.clear()
        love.graphics.circle('line', gw/2, gh/2, 50)
        self.area:draw()
    love.graphics.setCanvas()

    love.graphics.setColor(255, 255, 255, 255)
    love.graphics.setBlendMode('alpha', 'premultiplied')
    love.graphics.draw(self.main_canvas, 0, 0, 0, sx, sy)
    love.graphics.setBlendMode('alpha')
end
```

我们只是简单地调用[`love.graphics.draw`](https://love2d.org/wiki/love.graphics.draw)将画布绘制到屏幕上，还在调用前后用了一些[`love.graphics.setBlendMode`](https://love2d.org/wiki/love.graphics.setBlendMode)函数来进行设置。根据 LÖVE 维基上的说明，这样设置用于避免不正确的混合发生，如果你现在再运行游戏，则应该看到圆被绘制了出来。

请注意，我们使用`sx`和`sy`两个变量来放大画布，这些变量现在设置为 1，如果我们将其更改为 3，则显示效果如下：

![](https://camo.githubusercontent.com/0dda3a6870b2b372701c129921b58e6d01177125/687474703a2f2f692e696d6775722e636f6d2f6d784757766f6d2e706e67)

你什么也看不见！但这是因为之前位于`480 x 270`画布中间的圆，现在位于扩大 3 倍后`1440 x 810`画布的中间。由于我们屏幕还是只有`480 x 270`，因此此时圆位于可视范围之外。为了解决该问题，我们可以在`main.lua`中创建一个名为`resize`的函数，该函数将在每次改变屏幕尺寸或主动改变`sx`和`sy`时被调用：

```lua
function resize(s)
    love.window.setMode(s*gw, s*gh) 
    sx, sy = s, s
end
```

如果我们在`love.load`函数中调用`resize(3)`，将得到下面这样的效果：

![](https://camo.githubusercontent.com/24d2602e8a1b694079c5a73ddfc3b72da26ca5ae/687474703a2f2f692e696d6775722e636f6d2f43657a3456734b2e706e67)

这正是我们想要的。不过这里还有一个问题，圆看起来有些模糊，而不是被正确的像素化。

原因在于，无论何时在 LÖVE 按比例缩放对象时，都会使用 [FilterMode](https://love2d.org/wiki/FilterMode)，并且默认情况下此模式被设置为`'linear'`，由于我们希望游戏具有像素风，我们应将其改为`'nearest'`，通过在`love.load`开始时调用[`love.graphics.setDefaultFilter`](https://love2d.org/wiki/love.graphics.setDefaultFilter)并传递`'nearest'`参数可以解决该问题。另一件事是将 [LineStyle](https://love2d.org/wiki/LineStyle) 设置为`'rough'`。由于默认情况下，它被设置为`'smooth'`，LÖVE 图元在被绘制时会进行适当的抗锯齿，这也不适用于像素风。如果你修改完代码，在运行游戏，你将得到如下的效果：

![](https://camo.githubusercontent.com/c218198e26dee304ca6c132aa7e6dd3c8dcdae9a/687474703a2f2f692e696d6775722e636f6d2f454c30346462642e706e67)

它看起来就是我们想要的效果！最重要的是，我们现在可以使用一种分辨率来开发我们整个游戏。如果我们想要在屏幕中心生成一个对象，那么它的位置就在`gw / 2, gh / 2`，无论我们最终显示成多少分辨率，它始终在屏幕中心，这大大简化了我们对屏幕适配的处理。这意味着我们只需要关心在一个分辨率下游戏表现效果以及对象在屏幕上的位置即可。

## 游戏显示尺寸练习

65. 查看 [Steam 硬件调查](https://store.steampowered.com/hwsurvey/)中的 Primary Display Resolution 这一部分。最流行的，使用超过半数的分辨率是`1920x1080`，我们这款游戏基础分辨率可以整数倍放大至`1920x1080`。第二受欢迎的分辨率是`1366x768`，`480x270`不能整数倍放大至该分辨率。思考，当游戏全屏显示在玩家屏幕上时，哪些选项可以用来处理这些独特的分辨率？

66. 选择一个与我们这里使用的技术类似的游戏（将一个小的基础分辨率缩放至目标分辨率）。通常，像素风游戏会使用该技术。思考，该游戏的基础分辨率是多少？该游戏是如何处理不能整数倍扩大的独特分辨率？更改你电脑的分辨率以观察在不同分辨率下，该游戏显示效果会发生什么变化？如何处理这些变化？

## 摄像机

所有房间都将使用到摄像机，因此我们现在就可以开始介绍摄像机了。在本系列的第二篇文章中，我们使用了一个名为 [hump](https://github.com/vrld/hump) 的库中的计时器部分。这个库还有一个实用的摄像机模块，我们也将使用它。不过，我是用的是它经过略微修改后的版本，为其添加了震屏功能。你可以在[这里](https://github.com/SSYGEN/ModifiedCamera)下载修改后的文件。将`camera.lua`放置在 hump 库所在的目录下（将已存在的`camera.lua`覆盖掉），之后再`main.lua`中`require`它。并将`Shake.lua`文件放置在`objects`目录下。

*注：此外，你还可以使用我编写的[这个库](https://github.com/a327ex/STALKER-X)，它具备所有功能。我在写完整个教程之后才着手开发了该库，因此该教程将继续假装没有该库存在。如果你选择使用该库，你可以继续跟着教程，不过可能需要将其中某些用法替换为该库的用法。*

当你添加了摄像机模块后，你还需要新增一个函数：

```lua
function random(min, max)
    local min, max = min or 0, max or 1
    return (min > max and (love.math.random()*(min - max) + max)) or (love.math.random()*(max - min) + min)
end
```

此函数允许你在任意两个数字之间获取一个随机数。这是必需的，因为`Shake.lua`中使用到了它。在`utils.lua`中定义该函数之后，尝试执行如下代码：


```lua
function love.load()
    ...
    camera = Camera()
    input:bind('f3', function() camera:shake(4, 60, 1) end)
    ...
end

function love.update(dt)
    ...
    camera:update(dt)
    ...
end
```

接着在`Stage`类中做如下修改：

```lua
function Stage:draw()
    love.graphics.setCanvas(self.main_canvas)
    love.graphics.clear()
  	camera:attach(0, 0, gw, gh)
        love.graphics.circle('line', gw/2, gh/2, 50)
        self.area:draw()
  	camera:detach()
    love.graphics.setCanvas()

    love.graphics.setColor(255, 255, 255, 255)
    love.graphics.setBlendMode('alpha', 'premultiplied')
    love.graphics.draw(self.main_canvas, 0, 0, 0, sx, sy)
    love.graphics.setBlendMode('alpha')
end
```

当你按`f3`键时，你会看到屏幕震动：

![](https://camo.githubusercontent.com/adc97f2b2e10c052be2830c16eac8b1f3a303051/687474703a2f2f692e696d6775722e636f6d2f626764387277612e676966)

震动函数的实现基于[这篇文章](http://jonny.morrill.me/blog/view/14)所述内容，它具有振幅（以像素为单位）、频率和持续时间。屏幕将从给定的振幅开始，不断衰减，按照一定频率，震动持续数秒。较高的频率意味着屏幕将在两极`(amplitude, -amplitude)`之间剧烈波动，而较低的频率则相反。

另一个需要注意的重要事项是，摄像机现在还没有固定在某个位置上。因此，当它震动时，它会向四面八方移动，结束时并不会归位，如前面的动图所示。

解决此问题的一种方法是，将其锁定在中间位置，这可以通过[`camera.lockPosition`](http://hump.readthedocs.io/en/latest/camera.html#camera:lockPosition)函数做到。在摄像机模块的修改版本中，我修改了所有移动函数，令它们首先接受一个`dt`参数。因此代码如下所示：

```lua
function Stage:update(dt)
    camera.smoother = Camera.smooth.damped(5)
    camera:lockPosition(dt, gw/2, gh/2)

    self.area:update(dt)
end
```

将摄像机平滑器的`damped`设置为 5，这是通过反复实验得出的经验值，它使得摄像机通过一个平滑和优雅的方式聚焦到目标点上。我之所以将这段代码放在`Stage`类中，是因为我们现在正在使用`Stage`房间，并且这个房间里的摄像机正好需要被固定在屏幕中心永远不会移动（除了屏幕震动）。效果如下所示：

![](https://camo.githubusercontent.com/06f3ba9c058ac700d5fad75897e5433dcaf684dc/687474703a2f2f692e696d6775722e636f6d2f7a4742543259382e676966)

由于我们没有为每个房间都创建一个单独摄像机的需求，我们将会在游戏中使用一个全局摄像机。`Stage`房间只会使用到相机的震屏功能，因此，摄像机的介绍就先到这里。后面`Console`房间和`SkillTree`房间都将更加广泛地使用到摄像机功能，到时我们再继续接着介绍。

