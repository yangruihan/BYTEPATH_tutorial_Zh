# 第五章 玩家基本功能

*原文：https://github.com/a327ex/blog/issues/20*

## 简介

在本章中，我们将重点为`Player`类添加更多功能。首先，我们将重点放在玩家的攻击和发射子弹对象上。之后，我们将重点关注玩家的 2 个主要特性：加速（Boost）效果和更新（Cycle/Tick）效果。最后，我们将添加一个视觉效果完全不同的飞船到游戏中。从这一章开始，我们将只关注游戏性方面的内容，而前五章主要是基础建设（可以适用于任意游戏）。

## 玩家攻击

在此游戏中，玩家攻击的方式是：每隔 n 秒就会触发一次自动攻击。最终我们将拥有 16 中攻击类型，但几乎所有的攻击方式都是朝着玩家面对的方向发射不同的子弹。例如，下面是发射追踪导弹的效果：

![](https://camo.githubusercontent.com/638c9554bb09dd486d5304861e35b313e9505ae1/687474703a2f2f692e696d6775722e636f6d2f474e3048477a722e676966)

下面这个尽管设计速度更快，但发射的角度有些随机：

![](https://user-images.githubusercontent.com/409773/41510287-44baaac6-7238-11e8-9d56-768d33833a2b.gif)

虽然攻击和发射的子弹具有各种不同的属性，并且它们会受到不同事物的影响，但其核心逻辑始终是相同的。

为了达到上述效果，实现我们需要实现玩家每隔 n 秒攻击的逻辑。n 是一个根据攻击而变化的数字，默认值为 0.24。使用前面介绍的 Timer 库，我们可以轻松做到这一点：

```lua
function Player:new()
    ...
    self.timer:every(0.24, function()
        self:shoot()
    end)
end
```

添加上述代码后，我们将每隔 0.24 秒调用一次`Shoot`函数，我们将在该函数内添加实际创建子弹对象的代码。

现在，我们可以来设计`Shoot`函数内的逻辑了。首先，对于每一次设计，我们都将产生一个很小的视觉效果，用来表示当前射击了。我有一个好的经验法则是：每当实体对象在游戏中被创建或删除时，都为其添加一个伴随的视觉效果，这样掩盖了实体对象在屏幕上凭空出现和消失的事实，并且通常会使游戏感觉更棒。

要创建这个效果，首先我们需要创建一个名为`ShootEffect`的类（现在的你应该知道该如何创建）。这个效果只是在将要创建子弹的位置生成一个持续非常短时间的正方形。最简单的实现方法如下：

```lua
function Player:shoot()
    self.area:addGameObject('ShootEffect', self.x + 1.2*self.w*math.cos(self.r), 
    self.y + 1.2*self.w*math.sin(self.r))
end
```

```lua
function ShootEffect:new(...)
    ...
    self.w = 8
    self.timer:tween(0.1, self, {w = 0}, 'in-out-cubic', function() self.dead = true end)
end

function ShootEffect:draw()
    love.graphics.setColor(default_color)
    love.graphics.rectangle('fill', self.x - self.w/2, self.y - self.w/2, self.w, self.w)
end
```

看起来如下所示：

![](https://camo.githubusercontent.com/cb076ac928bbb35782c52f102bbfa9cf0f7e7d8f/687474703a2f2f692e696d6775722e636f6d2f347a414a6545632e676966)

上述效果代码非常直接。它只是一个变长为 8 的正方形，生命周期为 0.1 秒，并且在生命周期内，边长逐渐变为 0。现在有一个问题是，这个特效的位置静态的，它不会随着玩家的移动而移动。这看起来只是一个小细节，因为这个特效持续的时间非常短，不过一旦你把持续时间调整成 0.5 秒或更长时，你就会明白我说的问题了。

解决此问题的一种方法是将`Player`对象作为参数传递给`ShootEffect`对象，这样就可以通过下面这种方式来将`ShootEffect`的位置同步到`Player`对象了：

```lua
function Player:shoot()
    local d = 1.2*self.w

    self.area:addGameObject('ShootEffect', 
                            self.x + d*math.cos(self.r), 
                            self.y + d*math.sin(self.r), 
                            {player = self, d = d})
end

```lua
function ShootEffect:update(dt)
    ShootEffect.super.update(self, dt)
    if self.player then 
    	self.x = self.player.x + self.d*math.cos(self.player.r) 
    	self.y = self.player.y + self.d*math.sin(self.player.r) 
  	end
end

function ShootEffect:draw()
    pushRotate(self.x, self.y, self.player.r + math.pi/4)
    love.graphics.setColor(default_color)
    love.graphics.rectangle('fill', self.x - self.w/2, self.y - self.w/2, self.w, self.w)
    love.graphics.pop()
end
```

通过`opts`表在玩家射击时，将`ShootEffect`对象的`player`属性设置为`self`。这意味着，在`ShootEffect`对象中，可以通过`self.player`来访问到对应的`Player`对象。通常，这便是我们将一个对象引用传递给另一个对象的方式，因为大部分情况下，我们都是通过某个对象的某个方法来创建另一个对象，此时`self`就是我们想传递的变量。此外，我们还设置了一个`d`属性，它表示我们希望攻击效果出现的位置离玩家中心的距离，也是通过`opts`表来完成传递的。

然后在`ShootEffect`的`update`函数中，我们将其位置根据玩家的位置进行设置。务必始终检查要访问的引用是否被正确设置（通过`if self.player then`），因为如果没有正确设置引用，就会产生错误。很多时候，随着我们的代码量越来越大，会有很多对象在被其他对象引用时死亡，我们仍然会去访问这些对象的某些字段，但由于这些对象已经死亡，很可能对应的字段已经被置空，这时就会产生错误。像这样互相引用对象时，请务必牢记这一点。

最后一个细节是，我使方块效果与玩家的角度同步，然后再将其旋转 45 度以使其看起来更酷。通过`pushRotate`函数实现上述效果：

```lua
function pushRotate(x, y, r)
    love.graphics.push()
    love.graphics.translate(x, y)
    love.graphics.rotate(r or 0)
    love.graphics.translate(-x, -y)
end
```

这是一个将变换推入变换栈中的简单函数。实际上，它使所有接下来绘制的内容围绕`x, y`位置旋转`r`角度，直到我们调用[`love.graphics.pop`]()。在上面示例中，我们将正方形效果围绕其中心点旋转玩家当前的角度再加上 45 度（pi / 4 弧度）。为了完整起见，这里还提供了一个包含缩放的函数版本：

```lua
function pushRotateScale(x, y, r, sx, sy)
    love.graphics.push()
    love.graphics.translate(x, y)
    love.graphics.rotate(r or 0)
    love.graphics.scale(sx or 1, sy or sx or 1)
    love.graphics.translate(-x, -y)
end
```

这些函数非常实用，还将在我们整个游戏中使用，因此请确保你会使用它们，并了解它们！

## 玩家攻击练习

80. 如今，我们只需要在玩家的构造函数中使用默认构造的计时器，就可以每隔 0.24 秒调用一次射击函数。假设`Player`中存在一个`self.attack_speed`属性，该属性每 5 秒变化成 1 ~ 2 中的一个随机值：

    ```lua
    function Player:new(...)
    ...

    self.attack_speed = 1
    self.timer:every(5, function() self.attack_speed = random(1, 2) end)

    self.timer:every(0.24, function() self:shoot() end)
    ```

    思考：如何修改`Player`逻辑，使其每隔`0.24 / self.attack_speed`秒攻击一次？请注意，只是简单改一下`every`函数的第一个参数，是无法达到目的的。

81. 在上一篇教程中，我们讨论了垃圾回收以及被遗忘的引用是多么危险且会导致内存泄漏问题。在本文中，我介绍了在`Player`和`ShootEffect`实例中互相引用的示例。在该示例中，`ShootEffect`是一个短生命周期的对象，其中包含了对`Player`对象的引用，思考：我们是否需要关心显示取消对`Player`的引用，以便垃圾回收器能正确地回收`Player`对象？更一般的情况，什么情况下我们需要关心取消这样相互引用的对象？

82. 使用`pushRotate`将`Player`对象绕其中心旋转 180 度。效果如下：

    ![](https://camo.githubusercontent.com/bf861408c21ba9f2483dda5c20fdc296e0867618/687474703a2f2f692e696d6775722e636f6d2f4a434f626646552e676966)

83. 使用`pushRotate`将指示玩家移动方向的线绕其中心旋转 90 度。效果如下：

    ![](https://camo.githubusercontent.com/e3c34534764c207f5a8bc07cb3ce333dc7573110/687474703a2f2f692e696d6775722e636f6d2f567632646251542e676966)

84. 使用`pushRotate`将指示玩家移动方向的线绕玩家中心旋转 90 度。效果如下：

    ![](https://camo.githubusercontent.com/6ebf9753acf48ae30a2adeda9cfc7b6a678a0a23/687474703a2f2f692e696d6775722e636f6d2f6b4f7650754b572e676966)

85. 使用`pushRotate`将射击特效绕玩家中心旋转 90 度。效果如下：

    ![](https://camo.githubusercontent.com/ab870721148afe6729f9acbc1d46e6ee7099474f/687474703a2f2f692e696d6775722e636f6d2f31316c597463502e676966)

## 玩家弹幕

现在我们已经完成了射击特效，接下来我们将实现实际发射出去的子弹。子弹的运动机制与玩家的非常相似，它是一个具有一定初始角度的物理对象，然后我们将根据该角度设置其速度。让我们从`shoot`函数内部开始：

```lua
function Player:shoot()
    ...
    self.area:addGameObject('Projectile', self.x + 1.5*d*math.cos(self.r), 
    self.y + 1.5*d*math.sin(self.r), {r = self.r})
end
```

这些逻辑应该没有什么意外，我们使用上文提到的`d`变量来设置子弹的初始位置，然后将玩家的角度作为`r`属性进行传递。可以注意到，与`ShootEffect`对象不同，子弹在创建时，除了玩家的角度，不需要其他任何信息，因此我们不需要传递`Player`引用。

再来看一下子弹的构造函数。子弹对象将具有一个圆形碰撞体（像`Player`那样）属性、一个速度属性和一个指示其移动方向的属性：

```lua
function Projectile:new(area, x, y, opts)
    Projectile.super.new(self, area, x, y, opts)

    self.s = opts.s or 2.5
    self.v = opts.v or 200

    self.collider = self.area.world:newCircleCollider(self.x, self.y, self.s)
    self.collider:setObject(self)
    self.collider:setLinearVelocity(self.v*math.cos(self.r), self.v*math.sin(self.r))
end
```

`s`属性表示碰撞体的半径，这个属性名不是`r`是因为已经有一个属性`r`用来表示其移动的角度。通常，我会使用变量`w`、`h`、`r`或`s`来表示对象的尺寸。当对象是矩形时，我会使用前两个变量，当它是圆形时，我会使用后两个变量。如果`r`变量被用于表示某个方向时（如本例），则会用`s`表示半径。这些属性主要用于显示相关，因为大多数情况下，这些对象有对应的碰撞体来进行碰撞相关的工作。

这里我们所做的另一件事是，使用`opts.attrbute or default_value`进行构造（相关知识点我想已经在其他章节中介绍了）。借由 Lua 中`or`的工作方式，我们可以使用此写法来简化代码，逻辑等同于：

```lua
if opts.attribute then
    self.attribute = opts.attribute
else 
    self.attribute = default_value 
end
```

我们先检查属性是否存在，如果存在，则直接使用它，否则使用默认值。在我们的代码中，如果`opts.s`存在，则将`self.s`设置为其值，否则将其设置为 2.5。`self.v`同理。最后，我们使用[`setLinearVelocity`](https://love2d.org/wiki/Body:setLinearVelocity)来设置子弹的速度，其参数来自子弹的初始速度和从`Player`传入的角度。这里使用了与`Player`一样的移动逻辑，因此你应该可以理解它。

如果我们现在更新并绘制子弹，例如：

```lua
function Projectile:update(dt)
    Projectile.super.update(self, dt)
    self.collider:setLinearVelocity(self.v*math.cos(self.r), self.v*math.sin(self.r))
end

function Projectile:draw()
    love.graphics.setColor(default_color)
    love.graphics.circle('line', self.x, self.y, self.s)
end
```

看起来如下：

![](https://camo.githubusercontent.com/5398c646da3f66a69f242f1cbf1f65b78a009f1c/687474703a2f2f692e696d6775722e636f6d2f44526b686170332e676966)

## 玩家弹幕练习

86. 进入玩家射击函数，将创建出的弹幕尺寸（半径）改为 5，速度改为 150。

87. 修改玩家射击函数，使其同时发射 3 个子弹，其中 2 个子弹发射的角度为玩家当前角度 +-30 度，看起来如下：

    ![](https://camo.githubusercontent.com/5ae1d8abd4d09feef43c419b401c06137ded1471/687474703a2f2f692e696d6775722e636f6d2f5644464e655a582e676966)

88. 修改玩家射击函数，使其同时发射 3 个子弹，其中两边的 2 个子弹发射的位置为中间的子弹向两边偏移 8 个像素，看起来如下：

    ![](https://camo.githubusercontent.com/f6c8356134ac572b731e728c13611488c66fead4/687474703a2f2f692e696d6775722e636f6d2f726737683177582e676966)

89. 修改子弹初始速度为 100，当其创建出来后，在 0.5 秒内加速到 400。
